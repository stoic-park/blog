---
title: '원하는 컴포넌트를 PDF로 저장하기'
publishedAt: '2025-02-04'
summary: 'html2canvas와 jsPDF, 그리고 커스텀 훅 개선기'
tags: '#react, #pdf, #html2canvas, #jspdf, #hooks, #리팩토링'
author: 'Stoic Park'
category: 'react'
readingTime: '5분'
---

리액트로 개발을 하다 보면, 화면에 보이는 특정 컴포넌트를 그대로 이미지로 캡처해 PDF로 저장해야 하는 경우가 종종 있습니다. 저 역시 실무에서 차트, 테이블 등 다양한 형태의 데이터를 시각적으로 보여주면서 해당 화면을 PDF로 저장해 전달해야 하는 요구사항을 자주 마주쳤습니다.

초기에는 서버에서 데이터를 모아 문서로 만들어 제공하는 방식으로 구현했지만, 몇 가지 문제가 있었습니다:

1. PDF 생성 속도가 느림

2. 특정 조건에서 화질 저하 또는 레이아웃 깨짐 현상 발생

이를 해결하기 위해 팀에서는 백엔드에서 미리 PDF를 생성해 서버에 저장해두고 사용자 요청 시 내려주는 방식으로 결정하고 스프린트가 시작됐지만, 저는 이 구조가 화면의 시각적 완성도를 충분히 반영하지 못하고 있다고 느꼈습니다.

짧은 스프린트 일정 속에서도 고민 끝에, 화면을 캡처해 클라이언트에서 직접 PDF를 생성하는 방식을 검토하기 시작했습니다. 관련 기술을 조사하며 html2canvas와 jsPDF 조합이 속도 문제를 해결하면서도 문서 품질을 높일 수 있다는 확신이 생겼고, 다른 팀 개발자들의 피드백을 통해 실현 가능성도 검토할 수 있었습니다.

백엔드 리소스를 줄이는 동시에 UI 품질도 개선할 수 있다면 충분히 시도해볼 가치가 있다고 판단해, 팀을 설득하고 자투리 시간을 활용해 직접 구현에 나섰습니다.

이 글에서는 해당 기능을 구현하는 과정에서 사용한 html2canvas와 jsPDF의 활용법을 정리하고, 기능 중심으로 커스텀 훅을 리팩토링하여 재사용성을 높인 경험을 함께 공유합니다.

## 1. 문제 정의

레거시 프로젝트에서는 보고서 이미지 파일 위에 해당 텍스트를 추가해서 보고서를 만들었습니다.
하지만 다음과 같은 이슈들이 있었습니다:

- 해상도 저하 (특히 그래프나 UI 요소들이 흐릿하게 보임)
- 렌더링 시간이 길어 유저가 기다려야 함
- 백엔드 리소스를 소비하는 구조라 부담이 큼

이에 따라 다음과 같은 목표를 세웠습니다:

- 유저가 보는 **화면 그대로**를 PDF로 저장하고
- 고해상도에서도 깔끔하게 출력되며
- 백엔드 리소스를 소모하지 않는 구조

## 2. 해결 전략: 프론트엔드에서 직접 PDF 만들기

우선 사용할 기술 스택은 다음과 같습니다:

- [`html2canvas`](https://www.npmjs.com/package/html2canvas): DOM 요소를 이미지로 캡처
- [`jsPDF`](https://www.npmjs.com/package/jspdf): 이미지를 A4 PDF로 변환 및 저장
- `window.devicePixelRatio`: 고해상도 대응

이 조합이라면, 유저가 보는 UI를 그대로 캡처해서 PDF에 넣는 게 가능합니다.

## 3. 1차 구현 코드: 도메인 종속 훅 `useReportDownload`

처음에는 특정 도메인(예: 진단 보고서)에 맞춘 형태로 커스텀 훅을 만들었습니다.

```tsx
const useReportDownload = ({
  companyId,
  siteId,
  assetId,
  diagnosisDate,
  ref,
}) => {
  const reportData = useReportData({ ... });
  // ...
  const download = async () => {
    const canvas = await html2canvas(ref.current);
    const pdf = new jsPDF();
    pdf.addImage(canvas.toDataURL(), 'JPEG', 0, 0, 210, 297);
    pdf.save('보고서.pdf');
  };
  return { download };
};
```

### 기능은 잘 동작했지만...

- `companyId`, `siteId`, `diagnosisDate`와 같은 도메인 파라미터가 훅 내부에 있어 **다른 곳에서 재사용이 불가능**
- `useReportData`까지 훅 안에서 호출되어 **관심사가 뒤섞여 있음**

이건 **기능과 도메인을 분리**하지 못한 구조였고, 다른 곳에선 쓸 수 없는 "보고서 전용 훅"이 되어버렸습니다.

## 4. 코드 개선 방향 고민

이 훅이 정말 **보고서 전용**일까?  
사실 그렇지 않았습니다. **PDF로 저장해야 할 UI**는 보고서 외에도 많습니다.  
예를 들면:

- 리포트 요약
- 사용자 설정 정보
- 대시보드 스냅샷 등

그래서 다음과 같은 리팩토링 목표를 세웠습니다:

- 도메인 제거
- 기능 중심의 이름 부여 (`usePdfDownload`)
- 외부에서 `data`, `filename` 등을 주입받을 수 있도록 유연하게 변경

## 5. 개선된 훅: `usePdfDownload`

리팩토링 이후의 훅은 이렇게 바뀌었습니다:

```tsx
export const usePdfDownload = <T extends HTMLElement>({
 ref,
 filename = 'document.pdf',
 onBeforeDownload,
}: {
 ref: RefObject<T>
 filename?: string
 onBeforeDownload?: () => Promise<void> | void
}) => {
 // 캔버스와 jsPDF 객체 생성 및 다운로드 로직 생략
}
```

### 사용 예시

```tsx
const { download, loading } = usePdfDownload({
 ref,
 filename: '내보내기.pdf',
})
```

또는 캡처 전에 데이터를 불러오고 싶을 경우:

```tsx
const { download } = usePdfDownload({
 ref,
 onBeforeDownload: async () => {
  await fetchData() // 데이터 사전 준비
 },
})
```

이제 이 훅은 **어떤 UI에도 사용할 수 있는 범용 도구**가 되었습니다.

## 6. 결과 & 정리

최종적으로 구현된 PDF 다운로드 기능은:

- 고해상도 대응 (`devicePixelRatio`)
- 화면 UI 그대로 이미지화
- PDF 다중 페이지 지원
- 재사용 가능한 범용 커스텀 훅

으로 구성됐고, 결과적으로 아래와 같은 효과를 얻을 수 있었습니다.

- 시각적 품질 향상: 고해상도에서도 깔끔하게 출력
- 성능 개선: 프론트 단에서 처리해 속도 향상
- 범용성 확보: 다양한 UI에 재사용 가능
- 유지보수 용이: 관심사 분리 구조

## 데모: 직접 PDF로 저장해보세요

아래 박스를 PDF로 저장하는 버튼을 눌러 직접 테스트해보세요.

<DemoPdfBox />

---

📄 저장된 PDF에는 이 박스 안의 텍스트와 스타일이 그대로 담깁니다.

## usePdfDownload 훅 전체 코드

<details>
<summary>usePdfDownload.ts 전체 코드 보기</summary>

```tsx
import { RefObject, useCallback, useState } from 'react'
import html2canvas from 'html2canvas'
import jsPDF from 'jspdf'

export const usePdfDownload = <T extends HTMLElement>({
 ref,
 filename = 'document.pdf',
 onBeforeDownload,
}: {
 ref: RefObject<T>
 filename?: string
 onBeforeDownload?: () => Promise<void> | void
}) => {
 const [loading, setLoading] = useState(false)

 const download = useCallback(async () => {
  if (!ref.current) return

  try {
   setLoading(true)

   // 다운로드 전 실행할 작업이 있다면 실행
   if (onBeforeDownload) {
    await onBeforeDownload()
   }

   // 고해상도 대응을 위한 scale 설정
   const scale = window.devicePixelRatio
   const canvas = await html2canvas(ref.current, {
    scale,
    useCORS: true,
    logging: false,
   })

   // PDF 생성
   const pdf = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4',
   })

   // 이미지 크기 계산
   const imgWidth = 210 // A4 width in mm
   const imgHeight = (canvas.height * imgWidth) / canvas.width

   // PDF에 이미지 추가
   pdf.addImage(
    canvas.toDataURL('image/jpeg', 1.0),
    'JPEG',
    0,
    0,
    imgWidth,
    imgHeight,
   )

   // PDF 저장
   pdf.save(filename)
  } catch (error) {
   console.error('PDF 다운로드 중 오류 발생:', error)
   throw error
  } finally {
   setLoading(false)
  }
 }, [ref, filename, onBeforeDownload])

 return { download, loading }
}
```

</details>

## 7. 마무리하며

이 경험을 통해 크게 느낀 건 다음과 같습니다:

- **도메인과 기능을 명확히 분리하는 구조**는 재사용성과 유지보수를 극적으로 향상시킨다.
- **작은 기능도 관심사 분리 원칙에 따라 설계하면** 자연스럽게 확장성이 생긴다.
- 실무에서 생긴 문제를 기능으로 치환하고 개선해나가는 과정이 개발자에게 가장 좋은 공부다.

혹시 여러분도 화면 기반 PDF 출력 기능을 고민 중이라면,  
`html2canvas + jsPDF` 조합과 커스텀 훅 방식으로 접근해보는 것을 추천드립니다!
