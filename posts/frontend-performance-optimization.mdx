---
title: '프론트엔드 성능 최적화 3단계'
publishedAt: '2025-07-29'
summary: '프론트엔드 코드 레벨에서 적용할 수 있는 성능 최적화 기법들을 단계별로 정리한 가이드'
tags: '#프론트엔드, #성능최적화, #JavaScript, #React'
author: 'Stoic Park'
readingTime: '20분'
draft: true
---

이미지 -> 민감한 내용이 아닌것

프론트엔드 성능 최적화 얼마까지 알아보셨어요..?

# 개요

프론트엔드 성능 최적화라는 단어는.. 개발을 시작하면서 지금까지 항상 마음의 짐처럼 가지고 가는 단어인 것 같습니다

저의 경우 실무에서 프로젝트를 진행하다보면 성능에 대한 부분을 신경쓰지 못하고 기한에 맞춰 마무리를 진행하거나, 리팩토링의 과제로 넘겨야 했던 경우들이 존재했기 때문에 더욱더 아쉬움으로 다가오는 것 같은데요

돌이켜보면 성능 최적화에 대한 명확한 기준이나 가이드 없이, 주어진 상황에서 할 수 있는 성능 개선을 위한 방법들을 적용하고

스스로에게 성능 최적화를 진행했다 라고 했던 경우가 많았던 것 같습니다(양심고백)

최근 프론트엔드 성능 최적화에 대한 학습을 진행할 기회가 있었는데요

거기서 제가 경험하고 배운 내용들을 바탕으로 프론트엔드 성능 최적화를 3단계로 구분해보고 정리해보면서 저만의 가이드 문서를 만들고, 성능 최적화에 대한 내용을 정리해보겠습니다

## 1. 소개

- 가이드의 목적

* 이 글의 목적은 제가 두고두고 써먹고, 잊지 않기 위함입니다. 혹시 누군가에게도 도움이 됐다고 한다면 입꼬리를 막을 순 없겠습니다

- 대상 독자

* 저와 같은 경험을 하는 프론트엔드 개발자들에게 도움이 되도록 작성해보겠습니다

- 적용 범위

* 해당 글은 코드레벨의 최적화만을 다룰 예정입니다. 기회가 된다면 인프라 레벨의 최적화도 추후에 다뤄보겠습니다.

## 2. Step 1. 실행 로직 경량화

성능 최적화! 라고 하면 어떤 것을 먼저 떠오를까요. 구체적인 방법들이 존재하겠지만, 결국에는 내가 작성한 코드에서 그 원인을 찾아야 합니다.

저는 개발을 처음 시작할 때, 내가 작성한 코드들이 화면에 그려지는 것들이 참 신기하고 재밌었습니다.

하지만 그것이 어떤 단계를 거쳐 생성되는지는 생각하지 못했던 것 같습니다. 그 과정들을 이해해가는 과정을 거쳐가면서 아 프론트엔드 개발 쉽지 않은 영역이구나.. 라고 깨달아 가는 것 같습니다

그러기 위해서 프론트엔드 개발자 입장에서 할 수 있는 성능 최적화를 3단계로 나눠보려고 합니다.

### 2-1. 코드 분할 & 레이지 로딩

첫번째로 알아볼 내용은 코드 분할 & 레이지 로딩입니다.

MDN 문서에 코드 분할은 아래와 같이 설명되어 있습니다.

> 코드 분할(Code Splitting)은 코드를 번들된 코드 혹은 컴포넌트로 분리하는 것입니다. 이렇게하면 필요에 따라 특정한 컴포넌트만 로딩하거나, 병렬로 로딩할 수 있습니다.  
> 애플리케이션 복잡해지고 유지 관리에 의해, CSS와 JavaScript 파일이나 번들이 커지며, 특히 포함하고 있는 서드파티 라이브러리 개수, 용량이 클수록 커집니다.  
> 큰 파일을 다운로드하지 않도록, 스크립트를 작게 여러 파일로 분할할 수 있습니다. 그러면 화면 로딩할 때 필요한 기능은 바로 다운로드할 수 있으며, 추가 스크립트는 화면이나 애플리케이션 상호 작용시에 지연 로딩을 통해 기능 향상할 수 있습니다.  
> 코드 총량은 같지만(아마 파일 숫자나 용량은 늘어납니다), 초기 로딩에 필요한 코드는 적어집니다.  
> 코드 분할은 Webpack이나 Browserify 같이 번들러에서 지원하는 기능으로 런타임에 동적으로 로딩하는 여러 번들을 만들 수 있습니다.

갈수록 커지는 자바스크립트 번들 사이즈를 작은 청크로 잘게 다져 필요한 부분만 가져오도록 해서 성능을 최적화 하는 것입니다.

그렇다면, 코드스플리팅은 어떻게 할 수 있을까요?

사실 프레임워크를 활용한 개발에 익숙한 개발자라면, 자연스레 코드 스플리팅을 하고 있을 것입니다.

예를 들어,

{/* Create React App(CRA), Next.js, Vite 같은 현대 프레임워크/번들러는 기본적으로 번들 단위 분리(vendor, app, runtime 등)를 자동으로 해줍니다. */}
예를 들어, Next.js, Vite 같은 현대 프레임워크/번들러는 기본적으로 번들 단위 분리(vendor, app, runtime 등)를 자동으로 해줍니다.

라우트 단위로 코드가 분할되는 경우도 있으며, 특히 Next.js는 pages/ 라우터 또는 App Router에서 파일 단위로 자동 코드 스플리팅을 제공합니다.

즉, 우리는 초기 환경 설정만으로도, 최소한의 코드 스플리팅을 하고 있는 것입니다.

{/* 내가 이미지 */}

<div style={{ display: 'flex', justifyContent: 'center', flexDirection: 'column', alignItems: 'center' }}>
 <Image
  src="/images/2025-08-18-16-11-24.png"
  alt="Image"
  width={400}
  height={200}
 />
<p>코드 스플리팅.. 최적화.. 내가?</p>

</div>
{/* 내가 코드 스플리팅을..? */}

그러나, 보다 세밀한 코드 스플리팅을 하기 위해서는 우리가 직접 코드를 통해 최적화를 해주어야합니다.

그래서 해보는 것이, 어쩌면 익숙한 레이지 로딩 작업입니다.

환경에 따라 아래와 같은 방법들이 있습니다.

{/* 예시코드 */}

{/* React */}

#### React

```tsx
// 예시코드
import { lazy, Suspense } from 'react'

const Chart = lazy(() => import('./Chart')) // ./Chart를 별도 청크로 분리
export default function Dashboard() {
 return (
  <Suspense fallback={<div>차트 불러오는 중…</div>}>
   <Chart />
  </Suspense>
 )
}
```

{/* named export만 있을 경우 */}

#### named export만 있을 경우

```tsx
const MarkdownPreview = lazy(() =>
 import('./Markdown').then((m) => ({ default: m.MarkdownPreview })),
)
```

{/* React Router v6 */}

#### React Router v6

```tsx
import { createBrowserRouter, RouterProvider } from 'react-router-dom'
import { lazy, Suspense } from 'react'

const Home = lazy(() => import('./routes/Home'))
const Settings = lazy(() => import('./routes/Settings'))

const router = createBrowserRouter([
 {
  path: '/',
  element: (
   <Suspense fallback={<div>로딩…</div>}>
    <Home />
   </Suspense>
  ),
 },
 {
  path: '/settings',
  element: (
   <Suspense fallback={<div>로딩…</div>}>
    <Settings />
   </Suspense>
  ),
 },
])

export default () => <RouterProvider router={router} />
```

{/* Next.js */}

#### Next.js App Router 이후의 동적 임포트 흐름

Next.js 13(App Router)부터는 서버 컴포넌트(Server Components) 와 클라이언트 컴포넌트(Client Components) 개념이 도입되었습니다.
이로 인해 코드 스플리팅 전략에도 변화가 생겼습니다.

- 서버 컴포넌트: 기본적으로 서버에서 렌더링되므로, 클라이언트 번들에 포함되지 않아 자연스럽게 번들 크기가 줄어듭니다.

- 클라이언트 컴포넌트: \"use client\" 지시자를 붙인 경우에만 클라이언트 번들로 포함 → 이 영역에서 필요하다면 dynamic()을 통해 레이지 로딩 적용 가능

- dynamic import: App Router 환경에서도 여전히 사용 가능하며, 무거운 컴포넌트나 브라우저 전용 라이브러리를 지연 로딩할 때 활용합니다.

App Router는 기본적으로 서버 컴포넌트를 통해 클라이언트 번들을 가볍게 유지하도록 설계되어 있습니다.

즉, 코드 스플리팅이 기본 전제로 들어가 있는 셈입니다.

```tsx
'use client'
import dynamic from 'next/dynamic'

const Editor = dynamic(() => import('../components/Editor'), {
 ssr: false, // 브라우저 전용 라이브러리일 때
 loading: () => <div>에디터 로딩 중...</div>,
})

export default function Page() {
 return <Editor />
}
```

우리는 프로젝트 초기 환경설정부터, 코드스플리팅과 레이지로딩 전략을 잘 수립한다면 성능 최적화에 기반을 다지고 갈 수 있습니다.

---

### 2-2. 불필요한 렌더링 최소화

저에게는 성능 최적화 하면 가장 먼저 떠오르는 단계입니다

코드를 작성하면서 적은 코드로 큰 효과를 볼 수 있는 가장 익숙한 방법이기 때문입니다

우리는 React를 사용하면서 props, 상태의 변화가 없음에도 불구하고 리렌더링이 발생하는 상황에 부딪힐 때가 있었을텐데요

이 경우 브라우저의 메인 스레드에 과도한 연산이 발생하게 됩니다

그렇기 때문에 이러한 부분을 코드 단계에서 개선해줌으로써 눈에 띄는 성능 최적화를 이룰 수 있습니다

> 눈으로 확인할 수 있는 방법은 나중에 다른 글로 자세히 알아보겠습니다.

#### React.memo

React.memo는 props가 바뀌지 않았다면 컴포넌트를 다시 렌더링하지 않도록 메모이제이션하는 고차 컴포넌트(HOC)입니다.

공식 문서에서도 “불필요한 렌더링을 방지하고 성능을 최적화하는 방법”으로 권장됩니다.

```tsx
const UserCard = React.memo(function UserCard({ user }) {
 return <div>{user.name}</div>
})
```

- UserCard는 props가 변경되지 않는 한 다시 렌더링되지 않습니다.

- 단, React.memo는 **얕은 비교(shallow comparison)**만 수행하기 때문에, 객체/배열이 매번 새로 생성되면 여전히 리렌더링이 발생할 수 있습니다.

#### useMemo & useCallback

- useMemo: 값이 무거운 계산일 때, 메모이제이션된 결과를 반환합니다.

- useCallback: 함수를 메모이제이션하여, 하위 컴포넌트에 매번 새로운 함수가 전달되지 않도록 합니다.

```tsx
const memoizedValue = useMemo(() => {
 return heavySortedList(value)
}, [value])

const handleClick = useCallback(() => {
 console.log('clicked')
}, [])
```

공식 문서 표현을 빌리면,

- useMemo는 “매번 계산하지 않고, 이전에 계산한 값을 재사용할 수 있게 한다”

- useCallback은 **“매번 새로운 함수를 생성하지 않고, 동일한 함수를 재사용한다”**는 점에서 리렌더링 최적화에 유용합니다.

#### 컴포넌트 분리

개발을 진행하다보면, 처음 생각한 것과 다르게 하나의 컴포넌트가 맡는 기능이 많아지고, 그 크기가 커지는 경우가 있습니다.

하나의 큰 컴포넌트를 여러 작은 컴포넌트로 나누면, 실제로 변경이 일어난 부분만 리렌더링되도록 만들 수 있습니다.

저는 하나의 컴포넌트가 하나의 기능을 담당할 수 있도록 만드는것을 우선적으로 생각하는데요.

이것은 **단일 책임 원칙(Single Responsibility Principle, SRP)** 과도 그 결을 같이 한다고 생각합니다.

```tsx
// ❌ 안 좋은 예: 하나의 컴포넌트에 여러 책임이 뒤섞임
function UserDashboard({ user, notifications }) {
 return (
  <div>
   <h1>{user.name}님 환영합니다</h1>
   <button onClick={() => logout()}>로그아웃</button>
   <ul>
    {notifications.map((n) => (
     <li key={n.id}>{n.message}</li>
    ))}
   </ul>
  </div>
 )
}

// ✅ 좋은 예: 역할을 분리하여 각각의 책임만 담당
function UserGreeting({ user }) {
 return <h1>{user.name}님 환영합니다</h1>
}

function LogoutButton() {
 return <button onClick={() => logout()}>로그아웃</button>
}

const NotificationList = React.memo(function NotificationList({
 notifications,
}) {
 return (
  <ul>
   {notifications.map((n) => (
    <li key={n.id}>{n.message}</li>
   ))}
  </ul>
 )
})

function UserDashboard({ user, notifications }) {
 return (
  <div>
   <UserGreeting user={user} />
   <LogoutButton />
   <NotificationList notifications={notifications} />
  </div>
 )
}
```

#### 주의사항

위에서 제시한 내용들을 통해 우리는 리렌더링을 최적화 할 수 있습니다. 하지만 주의해야 할 부분이 명확히 존재합니다.

메모이제이션 도구(React.memo, useMemo, useCallback)를 남용하면 비교·캐싱 비용이 오히려 성능을 떨어뜨릴 수 있습니다.

따라서 Profiler 등 도구로 병목 지점을 확인한 뒤 적재적소에 적용하는 것이 중요합니다!

---

- 이벤트 델리게이션
- 디바운싱 / 쓰로틀링
- 메모리 누수 방지

## 3. Step 2. 렌더링 경로 최적화

- DOM 구조 최적화
- 시맨틱 태그 사용
- 크리티컬 CSS 인라인화
- GPU 친화적 애니메이션 (transform, opacity)
- 레이아웃 스래싱 방지
- will-change 속성 활용

## 4. Step 3. 자원 로딩 효율화

- 이미지 최적화 (WebP, AVIF 등)
- 폰트 최적화 (서브셋, font-display)
- 스프라이트 이미지 사용
- 가상 스크롤링 구현
- 프레임워크 특화 최적화 기법

## 5. 결론

- 단계별 점검 요약
- 장기적인 성능 유지 전략

## 6. 참고용 체크리스트

### ✅ Step 1. 실행 로직 경량화

- [ ] 초기 로딩 시 **코드 분할(Code Splitting)**과 **레이지 로딩(Lazy Loading)**을 적용했는가?
- [ ] **React.memo / useMemo / useCallback** 등 메모이제이션으로 불필요한 렌더링을 줄였는가?
- [ ] 이벤트를 개별 노드가 아닌 **상위 노드에서 위임(Delegation)**하고 있는가?
- [ ] **디바운싱 / 쓰로틀링**으로 입력·스크롤 이벤트 폭주를 제어했는가?
- [ ] 이벤트 리스너 해제, 타이머 클린업 등으로 **메모리 누수 방지**를 신경썼는가?
- [ ] DevTools Performance/Profiler에서 **Main thread, Scripting, INP** 지표를 확인했는가?

---

### ✅ Step 2. 렌더링 경로 최적화

- [ ] DOM 구조가 불필요하게 깊거나 복잡하지 않은가?
- [ ] 접근성과 최적화를 위해 **시맨틱 태그**를 적절히 사용했는가?
- [ ] **크리티컬 CSS 인라인화**로 초기 페인트 속도를 개선했는가?
- [ ] 애니메이션은 **transform/opacity** 기반으로 GPU 가속을 활용했는가?
- [ ] **레이아웃 스래싱**을 방지하기 위해 read/write 연산을 분리했는가?
- [ ] 성능 개선이 필요한 요소에만 **will-change** 속성을 부여했는가?
- [ ] DevTools Performance에서 **FPS, Layout/Paint, CLS** 지표를 점검했는가?

---

### ✅ Step 3. 자원 로딩 효율화

- [ ] 이미지 최적화를 위해 **WebP/AVIF** 같은 차세대 포맷을 사용했는가?
- [ ] 웹폰트는 **서브셋 제작** 및 `font-display` 속성을 활용했는가?
- [ ] 스프라이트 이미지, 아이콘 폰트, SVG Sprite 등을 적절히 사용했는가?
- [ ] 대용량 리스트 렌더링 시 **가상 스크롤링(Virtualized List)**을 적용했는가?
- [ ] Next.js `dynamic()` 또는 React.lazy를 활용해 **무거운 컴포넌트 로딩을 지연**했는가?
- [ ] Lighthouse, WebPageTest에서 **LCP, 리소스 Waterfall, Transfer size**를 측정했는가?

## 7. 참고 자료

- 공식 문서 및 추가 리소스
- [MDN -Code Splitting](https://developer.mozilla.org/ko/docs/Glossary/Code_splitting)
- [React.dev - React.lazy](https://ko.react.dev/reference/react/lazy#suspense-for-code-splitting)
- [React.dev - React.memo](https://ko.react.dev/reference/react/memo)
