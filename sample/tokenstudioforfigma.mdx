---
title: 'Figma 디자인 토큰을 vanilla-extract로 변환하기'
publishedAt: '2025-05-05'
summary: 'Figma 디자인 토큰을 vanilla-extract로 변환한 자동화 경험을 공유합니다.'
tags: '#Figma, #vanilla-extract, #React, #디자인 토큰'
author: 'Stoic Park'
readingTime: '5분'
---

디자인 시스템을 코드로 옮기는 과정에서 가장 시간이 많이 들고 반복적인 작업 중 하나는 디자인 토큰을 개발 코드에 반영하는 일입니다.

저희 팀은 Figma에서 Tokens Studio 플러그인을 통해 색상, 여백, 폰트 등의 토큰을 관리하고 있었는데,  
이를 vanilla-extract 스타일로 변환하는 작업은 매번 수동으로 작성해야 했고,  
구조가 바뀌거나 값이 수정될 때마다 매번 다시 정리해야 하는 번거로움이 있었습니다.

그래서 이를 자동화해보기로 했습니다.

## 수동 방식 기반 스크립트 개발

초기에는 디자인팀에서 Tokens Studio로부터 `tokens.json` 파일을 전달받는 수동 방식으로 진행했습니다.

이 JSON 파일은 다음과 같은 구조를 가지고 있었습니다:

```json
{
 "color": {
  "primary": { "value": "#FF0000" },
  "secondary": { "value": "#00FF00" }
 }
}
```

하지만 vanilla-extract는 아래와 같은 형식을 기대합니다:

```tsx
export const vars = createGlobalTheme(':root', {
 color: {
  primary: '#FF0000',
  secondary: '#00FF00',
 },
})
```

이를 위해 JSON을 읽고 변환해주는 간단한 스크립트를 작성했습니다.

```ts
// 1. JSON 구조 평탄화 (flatten)
function flattenTokens(json: any, path: string[] = []) {
 return Object.entries(json).flatMap(([key, value]) => {
  if (value?.value) {
   return [{ path: [...path, key], value: value.value }]
  }
  return flattenTokens(value, [...path, key])
 })
}

// 2. 평탄화된 데이터를 중첩된 JS 객체로 재구성 (nest)
function nestTokens(flatTokens: { path: string[]; value: string }[]) {
 const nested: Record<string, any> = {}
 for (const { path, value } of flatTokens) {
  let curr = nested
  path.forEach((key, idx) => {
   if (idx === path.length - 1) {
    curr[key] = value
   } else {
    curr[key] = curr[key] || {}
    curr = curr[key]
   }
  })
 }
 return nested
}

// 3. vanilla-extract용 코드로 변환 (createGlobalTheme 포맷)
function generateThemeCode(nested: object) {
 return `import { createGlobalTheme } from '@vanilla-extract/css';

export const vars = createGlobalTheme(':root', ${JSON.stringify(nested, null, 2)});
`
}
```

위 로직을 바탕으로 실행한다면 아래와 같습니다

```ts
import fs from 'fs'

const raw = JSON.parse(fs.readFileSync('./tokens.json', 'utf-8'))
const flat = flattenTokens(raw)
const nested = nestTokens(flat)
const output = generateThemeCode(nested)

fs.writeFileSync('./styles/tokens.css.ts', output)
```

## 변환 결과 및 수동 적용 방식

이 스크립트를 통해 매번 `tokens.json`만 갱신하면 `tokens.css.ts` 파일이 자동으로 생성되고,
이는 프로젝트에서 다음처럼 바로 사용할 수 있게 됩니다:

```ts
import { vars } from './tokens.css.ts'

style({
 backgroundColor: vars.color.primary,
})
```

덕분에 실수 없이 일관된 디자인 토큰을 유지할 수 있었고,
디자인 시스템을 유지보수하는 데 드는 리소스도 줄일 수 있었습니다.

## GitHub Actions 기반 자동화 도입

이후 개인적으로 GitHub Actions를 활용해, 디자인팀이 `tokens.json`을 갱신하면 자동으로 `tokens.css.ts`가 생성되도록 개선해보았습니다.

간단한 워크플로우를 작성해, push 시점에 변환 스크립트를 실행하고, 결과 파일을 커밋하도록 구성했습니다.

```yaml
# .github/workflows/generate-tokens.yml
name: Generate Tokens

on:
  push:
    paths:
      - 'design-tokens/tokens.json'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18
      - run: npm ci
      - run: npm run generate:tokens
      - run: git config user.name 'github-actions'
      - run: git config user.email 'actions@github.com'
      - run: git add styles/tokens.css.ts
      - run: git commit -m 'chore: auto generate tokens' || echo "No changes"
      - run: git push


이 과정을 통해 실제로 자동화 도입이 어떤 편리함을 주는지, 협업 단계에서 어떤 개선이 가능한지 실감할 수 있었습니다.
```

## 마무리 및 회고

디자인 시스템 자동화를 위한 첫 걸음을 수동 스크립트로 시작했고,
이후 GitHub Actions를 활용해 자동화까지 고도화해보면서 다양한 인사이트를 얻을 수 있었습니다.

디자인-개발 간의 협업 효율을 높이고 싶은 분들에게 추천하고 싶은 워크플로우입니다.

또한, 앞으로는 Tokens Studio의 API 또는 Style Dictionary와의 연동까지 확장해볼 계획입니다.
